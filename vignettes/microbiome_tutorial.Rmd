---
title: "Analysis of microbiome data with FAVA"
author: "Maike Morrison"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    theme: readable
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: true
---

<!-- vignette: > -->
<!--   %\VignetteIndexEntry{microbiome_tutorial} -->
<!--   %\VignetteEngine{knitr::rmarkdown} -->
<!--   %\VignetteEncoding{UTF-8} -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>",
  fig.width = 8
)
```

```{r setup}
library(FAVA)
library(dplyr)
library(tidyr)
library(ggplot2)
```

# Introduction

The _FAVA_ R package implements the statistic FAVA, an $F_{ST}$-based Assessment of Variability across vectors of relative Abundances, as well as a suite of helper functions which enable the visualization and statistical analysis of relative abundance data. The _FAVA_ R package package accompanies the paper, "FAVA: a tool to quantify compositional variability in microbial communities" by Morrison et al. (2023?). This tutorial provides a guide to the usage of the _FAVA_ R package for the analysis of microbiome data. 

The _FAVA_ R package includes the following core functions:

* `fava`: Compute FAVA among the rows of a relative abundance matrix

* `plot_relabund`: Visualize a relative abundance matrix as a stacked bar plot

* `bootstrap_fava`: Estimate the uncertainty in FAVA by generating bootstrap replicates of one or more relative abundance matrices and computing FAVA for each replicate matrix

* `window_fava`: Compute FAVA in sliding windows along the rows of a relative abundance matrix

The statistic FAVA summarizes the variability across the rows of a relative abundance matrix in a single index that ranges from 0 to 1. For typical microbiome data, the rows of each matrix represent microbiome samples and the entries of each row represent the relative abundance of a taxonomic category (e.g., OTU, species, or genus) or a functional category (e.g., gene family or enzyme abundance). Such matrices are often referred to as "OTU matrices." Taxonomic categories are usually inferred from 16S or metagenomic sequencing data, while functional categories are usually inferred from metagenomic sequencing data. You must obtain these relative abundances from your sequencing data before using the R package _FAVA_. 

FAVA can be used to quantify variability in many different contexts. For example,

* If each row corresponds to a time point, FAVA represents the temporal stability of the community. 

* If each row corresponds to a spatial sampling location, FAVA represents the spatial heterogeneity of the community. 

* If each row corresponds to a replicate in a community assembly experiment, FAVA represents the repeatability of the community assembly. 

* If each row represents a distinct individual, FAVA represents in the inter-individual variability in microbiome composition. 

### Overview

In this tutorial, we will explain the data required to use the _FAVA_ R package ([Data specifications]). We will then conduct an example data analysis using example data from Xue et al. ([Example Analysis]). We will use visualize the microbiome composition of three subjects over time, use FAVA to quantify the temporal variability across these microbiome samples, and explore these dynamics at a finer resolution using sliding windows over time. 

# Data specifications

To use _FAVA_, your data must be in the form of a matrix, data frame, or tibble with rows corresponding to samples and columns corresponding to categories such as bacterial species. If metadata (e.g. sample ID, time point, subject, experimental condition, replicate, etc.) are included, these columns must be on the left-hand side of the matrix, while the categories comprising the composition of the sample (e.g., bacterial species) must be on the right-hand side of the matrix. If your dataset contains metadata, you must specify `K`, the number of categories. While these categories can represent many things, we will for simplicity use "species" in this document to refer to the categories comprising each relative abundance sample.

Your matrix may contain samples from multiple groups you would like to analyze separately. In this case, you must provide the name of the column specifying the group each sample belongs to as the `group` parameter.

```{r, out.width = "1000px", echo = FALSE}
knitr::include_graphics("../Figures/schematic_data_structure_1.png")
```

You must read your data into R using a function such as `read.csv` and confirm that each sample sums to 1. If you use _phyloseq_, you must extract the OTU table. _phyloseq_ users may also wish to join their OTU table with their sample data table. Sample code for these tasks is provided below. 

```{r, eval=FALSE}
# Example code to read in a data set
my_data = read.csv("Path_to/my_data.csv")

# If your relative abundances are in a phyloseq object,
# make one object combining the sample data (left-hand side)
# and the OTU relative abundances (right-hand side)
my_data = cbind(sample_data(phyloseq_object),  
                t(otu_table(phyloseq_object)))

# Confirm that your samples each sum to 1
# if columns 4 through 10 contain the relevant categories
# and columns 1, 2, and 3 contain metadata
rowSums(my_data[,c(4:10)])

# Example code to convert counts to relative abundances 
my_data[,c(4:10)] = my_data[,c(4:10)]/rowSums(my_data[,c(4:10)])
```


**Optional: species similarity matrix** 

In order to compute a version of the FAVA variability statistic that accounts for the phylogenetic similarity between species, you must provide a matrix specifying the pairwise similarity of all species. Such a matrix can be easily generated from a phylogenetic tree of the species present in your samples. Microbiome analysis programs such as _phyloseq_ can generate a phylogenetic tree summarizing the evolutionary relationships among your sampled species. With a phylogenetic tree in hand, you must next convert the phylogenetic tree to a phylogenetic distance matrix using functions such as the function `cophenetic.phylo` in the _ape_ R package. If $D$ is the phylogenetic distance matrix, entry $D_{i,j}$ represents the phylogenetic distance between species $i$ and species $j$. Finally, you must convert the phylogenetic distance matrix to a similarity matrix, $S$. Whereas the distance between a species and itself is 0, the similarity between a species and itself is 1. For the example analysis here and in the manuscript, we use the transformation $S_{i,j}=\exp(-D_{i,j})$ to convert the phylogenetic distance matrix to a similarity matrix. Other transformations, such as $S_{i,j}=\frac{1}{D_{i,j}+1}$ or $S_{i,j}=1-\frac{D_{i,j}}{\max{(D_{i,j})}}$, are also suitable but result in a different mean similarity across species. It is important to confirm that the order and identity of the species in the similarity matrix match the order and identity of the species in your relative abundance matrix. Example code to generate a similarity matrix from a _phyloseq_ object is included below.

```{r, eval = FALSE}
tree = phy_tree(phyloseq_object)
distance_matrix = ape::cophenetic.phylo(tree)

# alternative similarity matrices:
similarity_matrix = 1/(distance_matrix + 1)
similarity_matrix = 1 - distance_matrix/max(distance_matrix)

# the similarity matrix we use:
similarity_matrix = exp(-distance_matrix)

# confirm that all diagonal elements are 1
diag(similarity_matrix)

# confirm that the entries of the similarity matrix
# correspond to the categories of your data
all(colnames(my_data[,c(4:10)]) == colnames(similarity_matrix))
```


# Example Analysis

In this tutorial, we visualize the composition of time-series microbiome samples from three subjects (1). For each subject, we compute the total variability across the study period (2). We also explore how compositional variability changes over time using a sliding window analysis (3).


### 0 - Example data

In this tutorial, we analyze the microbiome composition data generated by Xue et al. (2023) which is also analyzed in the FAVA manuscript. This example data set is included under the name `xue_microbiome_sample` as part of the _FAVA_ R package. `xue_microbiome_sample` is a dataframe containing 77 microbiome samples generated by Xue et al. (2023), each from one of three subjects (XBA, XDA, and XMA) at a series of time points between study day 1 and day 64. Each row of `xue_microbiome_sample` represents a single microbiome sample. `xue_microbiome_sample` has 526 columns: 

* `subject`: the subject each sample corresponds to 
  
* `timepoint`: the study day when each sample was collected
  
* `Actinomyces_sp_58647`, ..., `Xenorhabdus_bovienii_57960`: the relative abundance of the corresponding bacterial species (there are 524 species in total)

You can explore the structure of this data using the following functions:
```{r, eval=FALSE}
# open the data set in a new window
View(xue_microbiome_sample)

# view the structure of the data set
str(xue_microbiome_sample)
```

Here are the first ten rows and the first six columns of our example relative abundance matrix, `xue_microbiome_sample`:
```{r}
knitr::kable(xue_microbiome_sample[1:10, 1:6])
```

We also provide a pairwise similarity matrix, `xue_species_similarity`, which contains the similarity of every pair of species included in `xue_microbiome_sample`. Here are the first ten rows and the first four columns of our example pairwise similarity matrix, `xue_species_similarity`:
```{r}
knitr::kable(xue_species_similarity[1:10, 1:4])
```
And here we plot the similarity matrix as a heat map:
```{r, fig.height = 7}
ggplot(xue_species_similarity %>%
         data.frame() %>% 
         mutate(name2 = rownames(xue_species_similarity)) %>% 
         pivot_longer(cols = 1:524, 
                      values_to = "Similarity")) + 
  geom_raster(aes(x = name, 
                  y = name2, 
                  fill = Similarity)) + 
  theme_minimal() + scale_fill_viridis_c() +
  theme(axis.text.y = element_text(size = 2), 
        axis.text.x = element_text(size = 2, 
                                   angle = -90, 
                                   hjust = 0),
        axis.title = element_blank())
```

Note that:

* The diagonal elements of this matrix are all 1, since each species is identical to itself

* The columns and rows are in the same order (i.e., column 1 corresponds to the same species as row 1, etc.)

* The ordering of the species in the similarity matrix, `xue_species_similarity`, matches the ordering in the data, `xue_microbiome_sample`.


### 1 - Visualize relative abundances

We can visualize all of the relative abundances using the `plot_relabund` function:
```{r}
set.seed(1)
species_palette = viridis::turbo(524)[sample(1:524)] %>%
  `names<-`(colnames(xue_microbiome_sample)[-c(1:2)])

plot_relabund(xue_microbiome_sample,
              group = "subject", 
              time = "timepoint", 
              arrange = "vertical",
              K = 524) + 
  ggplot2::scale_color_manual(values = species_palette) + 
  ggplot2::scale_fill_manual(values = species_palette)
```

Our example data set contains relative abundance samples from multiple subjects that were taken at uneven timepoints. We can account for this in our visualization by providing the column name that describes which group each sample belongs to (`group = "subject"`) as well as which time each sample corresponds to (`time= "timepoint"`). Providing the `group` parameter results in a plot that has one facet for each subset. Providing the `time` parameter results in a plot where each sample may be repeated multiple times to reflect the number of days for which it informs the composition. Consider for reference the below plot which does not have the `time` parameter specified, and thus includes each sample exactly once.
```{r}
plot_relabund(xue_microbiome_sample,
              group = "subject", 
              arrange = "vertical", 
              K = 524) + 
  ggplot2::scale_color_manual(values = species_palette) + 
  ggplot2::scale_fill_manual(values = species_palette)
```

Consider also the below plot which specifies neither `time` nor `group` and instead plots all samples in a single plot,
```{r}
plot_relabund(xue_microbiome_sample,
              arrange = "vertical", 
              K = 524) + 
  ggplot2::scale_color_manual(values = species_palette) + 
  ggplot2::scale_fill_manual(values = species_palette)
```

In the above plots, we have specified `arrange = "vertical"`, which vertically arranges species from bottom to top in order of decreasing abundance. Specifying `arrange="horizontal"` horizontally arranges samples from left to right in order of increasing abundance of the most abundant species. Specifying `arrange=TRUE` or `arrange="both"` results in a plot with both types of ordering:
```{r}
plot_relabund(xue_microbiome_sample,
              arrange = "both", 
              K = 524) + 
  ggplot2::scale_color_manual(values = species_palette) + 
  ggplot2::scale_fill_manual(values = species_palette)
```

### 2 - Compute unweighted FAVA

This computation summarizes the variability across all rows from each group:
```{r}
fava(relab_matrix = xue_microbiome_sample, 
     group = "subject", 
     K = 524)
```

If `group` is not specified, FAVA is computed across all samples in the matrix:
```{r}
fava(relab_matrix = xue_microbiome_sample, 
     K = 524)
```

### 3 - Compute weighted FAVA

Providing a species similarity matrix `S` allows FAVA to account for the similarity among taxa. 

```{r}
fava(relab_matrix = xue_microbiome_sample, 
     group = "subject", 
     K = 524, 
     S = xue_species_similarity)
```

If the data set corresponds to time series data, as our example does, providing the name of the matrix column that specifies the time each sample was collected allows FAVA to compute a weighting vector based on these sampling times and implement this weighting vector in the computation. In `xue_microbiome_sample`, the column is called "timepoint." 
```{r}
fava(relab_matrix = xue_microbiome_sample, 
     group = "subject", 
     K = 524, 
     time = "timepoint")
```

An arbitrary weighting vector can instead be provided to the `fava` function as the `w` parameter. You may provide either `w` or `time` but not both.  `w` must have length equal to the number of rows in your data set. If `w` provides the weights for one computation of FAVA (i.e., a single group) its entries must sum to 1. If `w` provides weights for multiple groups, each subset of `w` corresponding to a single group must sum to 1.  We can manually compute such a vector using the function `time_weights`. 

For example, consider only subject XMA We first create a data frame, `XMA`, containing only samples from subject XMA We then compute a weighting vector based on the times at which subject XMA collected samples, `XBA$timepoint`.
```{r}
XMA = filter(xue_microbiome_sample, subject == "XMA")
XMA$timepoint

weights = time_weights(times = XMA$timepoint)
weights
sum(weights)
```

When we plot each sample's weight based on when that sample was collected, we see that the daily samples during the middle of the study period have lower weights than the weekly samples during the beginning and end of the study. We see that the subject missed a day of sampling in the middle of the study, and the samples before and after this missed day have slightly higher weights than the other daily samples.
```{r}
ggplot(mapping = aes(x = XMA$timepoint, 
                     y = weights)) + 
  geom_bar(stat = "identity") + 
  theme_bw()
```

We can use this weighting vector to compute the temporal variability of subject XMA. Note that we get the same value of FAVA as when we specified the `time` parameter above. 
```{r}
fava(relab_matrix = XMA, 
     K = 524, 
     w = weights)
```


You may incorporate both species similarity (specifying `S`) and uneven row weightings (specifying `w` or `time`) into the computation of FAVA. 
```{r}
fava(relab_matrix = xue_microbiome_sample, 
     group = "subject", 
     K = 524, 
     time = "timepoint",
     S = xue_species_similarity)
```

We will specify both `S` and `time` in our analysis of this data set because it contains many species, some very similar and some very distantly related, and because the sampling scheme is uneven, containing some weekly samples and some daily samples. 


### 4 - Sliding windows

#### Compute FAVA for each window
```{r}
# window_out = window_fava( Q = xue_microbiome_sample,
#                          K = 524,
#                          w = time_weights(times = xue_microbiome_sample$timepoint, 
#                               group = xue_microbiome_sample$subject),
#                          S = sp.sim,
#                          window_size = 6, 
#                          group = "subject", 
#                          index = "timepoint")
# head(window_out)
```

#### Visualize FAVA in sliding windows
```{r}
# window_plot(window_out)
# window_plot(window_out) + facet_wrap(~ group)
```

